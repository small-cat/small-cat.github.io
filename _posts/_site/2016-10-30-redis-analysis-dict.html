<p>redis 字典对象分析</p>

<p>字典，又称为符号表 (symbol table)、关联数组 (associated array)或映射 (map)，是一种用于保存键值对 (key-value pair)的抽象数据结构。在 redis 中，哈希键和数据库都是通过字典作为底层实现的。</p>

<h1 id="结构体">结构体</h1>
<p>redis 中字典的结构如下：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="n">typedef</span> <span class="n">struct</span> <span class="n">dictEntry</span> <span class="p">{</span>
	    <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>	<span class="sr">//</span><span class="err">键</span>
	    <span class="n">union</span> <span class="p">{</span>
	        <span class="n">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
	        <span class="n">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
	        <span class="n">int64_t</span> <span class="n">s64</span><span class="p">;</span>
	        <span class="n">double</span> <span class="n">d</span><span class="p">;</span>
	    <span class="p">}</span> <span class="n">v</span><span class="p">;</span>	<span class="sr">//</span><span class="err">值，使用联合体，可以是指针，也可以是其他类型的值</span>
	    <span class="n">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="k">next</span><span class="p">;</span>	<span class="sr">//</span><span class="err">使用拉链法解决哈希冲突问题</span>
	<span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span></code></pre></figure>

<p>对两个64位类型解释如下</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef unsigned __int64 uint64_t;
typedef signed __int64 int64_t;
</code></pre></div></div>

<p>可以将 <code class="highlighter-rouge">__int64</code>理解成 <code class="highlighter-rouge">long long</code></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="n">typedef</span> <span class="n">struct</span> <span class="n">dictType</span> <span class="p">{</span>
	    <span class="n">unsigned</span> <span class="n">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hashFunction</span><span class="p">)(</span><span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
	    <span class="n">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">keyDup</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
	    <span class="n">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">valDup</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
	    <span class="n">int</span> <span class="p">(</span><span class="o">*</span><span class="n">keyCompare</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
	    <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keyDestructor</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
	    <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">valDestructor</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">dictType</span><span class="p">;</span></code></pre></figure>

<p><code class="highlighter-rouge">dictType</code>结构体为一簇操作特定类型键值对的函数，<code class="highlighter-rouge">privdata</code>为传给这些函数的可选参数</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* This is our hash table structure. Every dictionary has two of this as we
	 * implement incremental rehashing, for the old to the new table. */</span>
	<span class="n">typedef</span> <span class="n">struct</span> <span class="n">dictht</span> <span class="p">{</span>
	    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>
	    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">size</span><span class="p">;</span>
	    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">sizemask</span><span class="p">;</span>
	    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">used</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">dictht</span><span class="p">;</span></code></pre></figure>

<p>dictht 为哈希表结构，哈希表结构有一个 dictEntry 的双重指针（可理解成 dictEntry 指针数组），size 为哈希表大小，sizemask 为哈希表大小掩码，用于计算哈希索引值，总是等于 <code class="highlighter-rouge">size-1</code>，used 为哈希表元素个数，即已有的节点的数量。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	
	<span class="n">typedef</span> <span class="n">struct</span> <span class="n">dict</span> <span class="p">{</span>
	    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	    <span class="n">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span>
	    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	    <span class="n">long</span> <span class="n">rehashidx</span><span class="p">;</span> <span class="sr">/* rehashing not in progress if rehashidx == -1 */</span>
	    <span class="n">int</span> <span class="n">iterators</span><span class="p">;</span> <span class="sr">/* number of iterators currently running */</span>
	<span class="p">}</span> <span class="n">dict</span><span class="p">;</span></code></pre></figure>

<p>dict 为字典结构，包括两个哈希表ht[2], 一个用于正常使用，另一个，当需要扩大哈希表时，将ht[0]中的节点rehashed 到 ht[1] 上，然后再将 ht[1] 设置为ht[0], ht[1]置空，准备下一次 rehashed。 rehashidx 记录了 rehash 的进度，当没有做 rehash 时，它的值为 -1， 当在做 rehash 的值时，它的值表示的是当前 rehash 到了 ht[0] 中的哪一个位置了(可以理解成 ht[0].table[rehashidx])。 redis 的 rehash 是渐进式的，即通过 rehashidx 一个一个递增的形式 rehash 的。</p>

<h1 id="字典的详细实现">字典的详细实现</h1>
<h2 id="计算哈希值和索引值">计算哈希值和索引值</h2>
<p>redis计算哈希值和索引值，是根据键值来计算的，先计算出哈希值，然后根据哈希值和 sizemask 计算索引值。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* Returns the index of a free slot that can be populated with
	 * a hash entry for the given 'key'.
	 * If the key already exists, -1 is returned.
	 *
	 * Note that if we are in the process of rehashing the hash table, the
	 * index is always returned in the context of the second (new) hash table. */</span>
	<span class="n">static</span> <span class="n">int</span> <span class="n">_dictKeyIndex</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="n">unsigned</span> <span class="n">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">table</span><span class="p">;</span>
	    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">he</span><span class="p">;</span>
	
	    <span class="sr">/* Expand the hash table if needed */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">_dictExpandIfNeeded</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="no">DICT_ERR</span><span class="p">)</span>		<span class="o">/</span><span class="sr">/判断是否需要扩大哈希表的大小，如果正在 rehash，返回 true
													/</span><span class="o">/</span><span class="err">如果</span><span class="n">used</span><span class="o">/</span><span class="n">size</span> <span class="err">大于安全阀值</span><span class="mi">5</span><span class="err">时，将需要扩大哈希表大小</span>
	        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	    <span class="sr">/* Compute the key hash value */</span>
	    <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>		<span class="sr">//</span><span class="err">计算哈希值</span>
	    <span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">table</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">idx</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="nf">sizemask</span><span class="p">;</span>	<span class="sr">//</span><span class="err">计算索引值，在哈希表中查找是否存在，存在返回</span><span class="o">-</span><span class="mi">1</span><span class="err">，不存在，返回索引值</span>
	        <span class="sr">/* Search if this slot does not already contain the given key */</span>
	        <span class="n">he</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="nf">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	        <span class="k">while</span><span class="p">(</span><span class="n">he</span><span class="p">)</span> <span class="p">{</span>
	            <span class="k">if</span> <span class="p">(</span><span class="n">dictCompareKeys</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
	                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	            <span class="n">he</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="k">next</span><span class="p">;</span>
	        <span class="p">}</span>
	        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>上面这个函数，为获取哈希值和索引值的过程， 首先通过 <code class="highlighter-rouge">dictHashKey(d, key)</code> 获取哈希值，这是一个宏函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)
</code></pre></div></div>

<p>然后根据哈希值求索引值，<code class="highlighter-rouge">idx = h &amp; d-&gt;ht[table].sizemask</code>，如果此元素在哈希表中已存在，返回-1，不需要再次插入，否则返回一个可以用的位置。搜索哈希表时，需要在两个哈希表中都要搜索。</p>

<p>那么，当 <code class="highlighter-rouge">_dictExpandIfNeed (d)</code> 判断出需要扩大哈希表时，是如何扩大哈希表的呢？<code class="highlighter-rouge">_dictExpandIfNeed (d)</code>这个函数在判断时： <br /></p>
<ol>
  <li>如果 <code class="highlighter-rouge">rehashidx ！= -1</code> 说明，哈希表在 <code class="highlighter-rouge">rehash</code>，此时表明就是正在扩大哈希<br /></li>
  <li>如果 <code class="highlighter-rouge">used/size</code> （这两个都是 <code class="highlighter-rouge">dictht</code> 的成员）大于阀值 <code class="highlighter-rouge">dict_force_resize_ratio</code>（为5）时，就需要扩大哈希表。</li>
</ol>

<p>扩大哈希表的函数如下</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* Expand or create the hash table */</span>
	<span class="n">int</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="n">size</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="n">dictht</span> <span class="n">n</span><span class="p">;</span> <span class="sr">/* the new hash table */</span>
	    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">realsize</span> <span class="o">=</span> <span class="n">_dictNextPower</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	
	    <span class="sr">/* the size is invalid if it is smaller than the number of
	     * elements already inside the hash table */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">||</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">used</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>	<span class="o">/</span><span class="sr">/如果rehashidx不是-1，说明正在扩，不需重复操作；而且扩大后，used 应该小于 size
	        return DICT_ERR;
	
	    /</span><span class="o">*</span> <span class="no">Rehashing</span> <span class="n">to</span> <span class="n">the</span> <span class="n">same</span> <span class="n">table</span> <span class="n">size</span> <span class="n">is</span> <span class="n">not</span> <span class="n">useful</span><span class="p">.</span> <span class="nf">*</span><span class="o">/</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">realsize</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">size</span><span class="p">)</span> <span class="k">return</span> <span class="no">DICT_ERR</span><span class="p">;</span>
	
	    <span class="sr">/* Allocate the new hash table and initialize all pointers to NULL */</span>
	    <span class="n">n</span><span class="p">.</span><span class="nf">size</span> <span class="o">=</span> <span class="n">realsize</span><span class="p">;</span>
	    <span class="n">n</span><span class="p">.</span><span class="nf">sizemask</span> <span class="o">=</span> <span class="n">realsize</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	    <span class="n">n</span><span class="p">.</span><span class="nf">table</span> <span class="o">=</span> <span class="n">zcalloc</span><span class="p">(</span><span class="n">realsize</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">dictEntry</span><span class="o">*</span><span class="p">));</span>
	    <span class="n">n</span><span class="p">.</span><span class="nf">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	    <span class="sr">/* Is this the first initialization? If so it's not really a rehashing
	     * we just set the first hash table so that it can accept keys. */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">table</span> <span class="o">==</span> <span class="no">NULL</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	        <span class="k">return</span> <span class="no">DICT_OK</span><span class="p">;</span>
	    <span class="p">}</span>
	
	    <span class="sr">/* Prepare a second hash table for incremental rehashing */</span>
	    <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>	<span class="sr">//</span> <span class="err">将</span> <span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">设置为扩大后的哈希表，然后将</span> <span class="n">rehashidx</span> <span class="err">置为</span><span class="mi">0</span><span class="err">，表明从</span> <span class="mi">0</span> <span class="err">开始</span> <span class="n">rehash</span>
	    <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="k">return</span> <span class="no">DICT_OK</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>此函数需要注意最后一段代码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    d-&gt;ht[1] = n;	
    d-&gt;rehashidx = 0;
</code></pre></div></div>

<p>将扩大后的哈希设置为 ht[1]，然后设置 rehashidx 为0，启动 rehash，将 ht[0] 都 从 ht[0].table[0] 开始全部 rehash 到 ht[1].table 中，后面将详细介绍 redis 的 rehash 的过程。</p>

<h3 id="计算哈希值">计算哈希值</h3>
<p>字典在计算哈希值时，是通过调用宏函数 <code class="highlighter-rouge">(d)-&gt;type-&gt;hashFunction (key)</code>得到的，这只是一个函数指针，在 redis 中，有两个方法计算哈希值。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* MurmurHash2, by Austin Appleby
	 * Note - This code makes a few assumptions about how your machine behaves -
	 * 1. We can read a 4-byte value from any address without crashing
	 * 2. sizeof(int) == 4
	 *
	 * And it has a few limitations -
	 *
	 * 1. It will not work incrementally.
	 * 2. It will not produce the same results on little-endian and big-endian
	 *    machines.
	 */</span>
	<span class="n">unsigned</span> <span class="n">int</span> <span class="n">dictGenHashFunction</span><span class="p">(</span><span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	    <span class="sr">/* 'm' and 'r' are mixing constants generated offline.
	     They're not really 'magic', they just happen to work well.  */</span>
	    <span class="n">uint32_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">dict_hash_function_seed</span><span class="p">;</span>
	    <span class="n">const</span> <span class="n">uint32_t</span> <span class="n">m</span> <span class="o">=</span> <span class="mh">0x5bd1e995</span><span class="p">;</span>
	    <span class="n">const</span> <span class="n">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
	
	    <span class="sr">/* Initialize the hash to a 'random' value */</span>
	    <span class="n">uint32_t</span> <span class="n">h</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">^</span> <span class="n">len</span><span class="p">;</span>
	
	    <span class="sr">/* Mix 4 bytes at a time into the hash */</span>
	    <span class="n">const</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">;</span>
	
	    <span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">uint32_t</span> <span class="n">k</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	
	        <span class="n">k</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
	        <span class="n">k</span> <span class="o">^=</span> <span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
	        <span class="n">k</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
	
	        <span class="n">h</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
	        <span class="n">h</span> <span class="o">^=</span> <span class="n">k</span><span class="p">;</span>
	
	        <span class="n">data</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	        <span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	    <span class="p">}</span>
	
	    <span class="sr">/* Handle the last few bytes of the input array  */</span>
	    <span class="n">switch</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="n">h</span> <span class="o">^=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="n">h</span> <span class="o">^=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="n">h</span> <span class="o">^=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">h</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
	    <span class="p">};</span>
	
	    <span class="sr">/* Do a few final mixes of the hash to ensure the last few
	     * bytes are well-incorporated. */</span>
	    <span class="n">h</span> <span class="o">^=</span> <span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">;</span>
	    <span class="n">h</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
	    <span class="n">h</span> <span class="o">^=</span> <span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
	
	    <span class="k">return</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">int</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>当字典被用作数据库的底层实现或者哈希键的底层实现时， <code class="highlighter-rouge">redis</code> 使用 <code class="highlighter-rouge">Murmurhash2</code> 算法来计算哈希的值。 <code class="highlighter-rouge">Murmurhash</code> 哈希算法是有 <code class="highlighter-rouge">Austin Appleby</code> 与 2008 年发明的，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* And a case insensitive hash function (based on djb hash) */
// 这是一个比较简单的计算哈希值的方法，字符串哈希，就是不断乘以33
unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) {
    unsigned int hash = (unsigned int)dict_hash_function_seed;		//哈希方法的种子

    while (len--)
        hash = ((hash &lt;&lt; 5) + hash) + (tolower(*buf++)); /* hash * 33 + c */
	//hash &lt;&lt; 5 + hash = hash * 2^5 + hash = hash * 32 + hash = hash * 33
    return hash;
}
</code></pre></div></div>

<h2 id="解决键冲突">解决键冲突</h2>
<p>当不同的 key 利用哈希算法得到相同的 hash 值时，哈希表时如何解决冲突问题的呢？通过前面的哈希节点的结构可以看到<code class="highlighter-rouge">dictEntry</code>结构是一个链表的节点，有一个指向 <code class="highlighter-rouge">dictEntry</code>节点的指针成员，确实，哈希表就是通过拉链法（或者链地址法）来解决冲突问题的，每一个哈希节点都有一个next指针，相同哈希索引的多个节点可以通过next指针相连构成一个单链表，这就解决了冲突问题。<br />
<img src="https://github.com/small-cat/small-cat.github.io/raw/master/_pics/redis_analysis/hash_list.png" alt="hash list" /></p>

<p>因为dictEntry 组成的单链表是没有尾节点的，每次插入一个节点都是从头部插入。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* Low level add. This function adds the entry but instead of setting
	 * a value returns the dictEntry structure to the user, that will make
	 * sure to fill the value field as he wishes.
	 *
	 * This function is also directly exposed to the user API to be called
	 * mainly in order to store non-pointers inside the hash value, example:
	 *
	 * entry = dictAddRaw(dict,mykey);
	 * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);
	 *
	 * Return values:
	 *
	 * If key already exists NULL is returned.
	 * If key was added, the hash entry is returned to be manipulated by the caller.
	 */</span>
	<span class="sr">/*如果key已经在哈希表中已经存在，返回NULL；否则返回该哈希节点*/</span>
	<span class="n">dictEntry</span> <span class="o">*</span><span class="n">dictAddRaw</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="n">int</span> <span class="n">index</span><span class="p">;</span>
	    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	    <span class="n">dictht</span> <span class="o">*</span><span class="n">ht</span><span class="p">;</span>
	
		<span class="sr">/* 判断是否正在 rehash，正在 rehash 中的哈希表与没有 rehash 的哈希表插入操作不同
		 1. 当 rehash 时，需要将ht[0] 中的所有节点 rehash 到 ht[1]中，这时，为了保证ht[0]中的节点是一直减少的，插入时插入到ht[1]中
		 2. 没有 rehash ，直接将节点插入到 ht[0]中
		*/</span>	
	    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="n">_dictRehashStep</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>	
	
	    <span class="sr">/* Get the index of the new element, or -1 if
	     * the element already exists. */</span>
	    <span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">=</span> <span class="n">_dictKeyIndex</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	        <span class="k">return</span> <span class="no">NULL</span><span class="p">;</span>
	
	    <span class="sr">/* Allocate the memory and store the new entry */</span>
	    <span class="n">ht</span> <span class="o">=</span> <span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">?</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	    <span class="n">entry</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">));</span>
	    <span class="n">entry</span><span class="o">-&gt;</span><span class="k">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>		<span class="sr">//</span><span class="err">从链表头插入</span>
	    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>
	
	    <span class="sr">/* Set the hash entry fields. */</span>
	    <span class="n">dictSetKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	    <span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>从链表头插入，不需要单向遍历到链表尾部在插入节点，降低了插入节点时的时间复杂度 O(1)</p>
<h2 id="rehash">rehash</h2>
<p>哈希表的一个重要的比例参数为_负载因子_(load factor)，它的计算公式为</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>load_factor = used / size; //代码中的注释为 USED/BUCKETS ratio
</code></pre></div></div>

<p>随着操作的不断进行，哈希表中的节点会逐渐的增加或者减少，为了维持 load factor 在合适的范围之内，程序需要对哈希表进行扩展 (expand) 或者收缩，而这，是通过 rehash 来完成的。</p>

<blockquote>
  <p>redis 对字典的哈希表进行 rehash 操作的步骤如下： <br />
1) 为 ht[1] 分配空间，这个空间的大小取决于要执行的操作（扩展还是收缩），以及 ht[0] 当前包含的键值对的数量（ht[0].used）: <br />
　　a. 如果是扩展操作，ht[1] 的大小为不小于 ht[0].used*2 的 2^n；<br />
　　b. 如果是收缩操作，ht[1] 的大小为不小于 ht[0].used 的 2^n <br />
2) 将 ht[0] 保存的所有键值对 rehash 到 ht[1] 中， rehash 是指重新计算哈希值和索引值，然后保存到 ht[1] 中； <br />
3) 当 ht[0] 上的所有键值对都迁移到了 ht[1] 上之后（此时ht[0]是一张空表），释放 ht[0]，同时将 ht[1] 设置为 ht[0]，在为 ht[1] 创建一个空表哈希，为下一次 rehash 做准备。 <br /></p>
</blockquote>

<p><strong>引用中的内容摘自 黄健宏的《Redis设计与实现》4.4节 rehash</strong></p>

<h3 id="扩展">扩展</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Using dictEnableResize() / dictDisableResize() we make possible to
 * enable/disable resizing of the hash table as needed. This is very important
 * for Redis, as we use copy-on-write and don't want to move too much memory
 * around when there is a child performing saving operations.
 *
 * Note that even when dict_can_resize is set to 0, not all resizes are
 * prevented: a hash table is still allowed to grow if the ratio between
 * the number of elements and the buckets &gt; dict_force_resize_ratio. */
static int dict_can_resize = 1;
static unsigned int dict_force_resize_ratio = 5;
</code></pre></div></div>

<p>以上两个 static 变量说明的是允许哈希表进行扩展或者收缩的前提条件。</p>

<p>redis 使用了写时复制的原则（COW），打个比方，当父进程创建子进程时，这时，采用写时复制的原则，父子进程访问的数据都是同一份拷贝，只有当其中一个需要对数据进行修改时，才会将父进程的内容拷贝一份给子进程，这样能够极大的节约内存。所以，当 redis 创建服务器子进程时，通过写时复制原则节约内存，就希望在子进程存在期间，尽可能的不要对哈希表进行扩展操作，服务器通过增大负载因子来达到这一目的，从而最大限度的节约内存。</p>

<p><code class="highlighter-rouge">dict_can_resize</code>设置为1时，表示哈希表可以扩展或者收缩，设置为0时，表示不能操作，但是，当负载因子超过阈值 <code class="highlighter-rouge">dict_forece_resize_ratio</code>时，会强制进行扩展操作。上文也介绍了 <code class="highlighter-rouge">_dictExpandIfNeeded</code>这个函数</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* Expand the hash table if needed */</span>
	<span class="n">static</span> <span class="n">int</span> <span class="n">_dictExpandIfNeeded</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="sr">/* Incremental rehashing already in progress. Return. */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="no">DICT_OK</span><span class="p">;</span>
	
	    <span class="sr">/* If the hash table is empty expand it to the initial size. */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="no">DICT_HT_INITIAL_SIZE</span><span class="p">);</span>
	
	    <span class="sr">/* If we reached the 1:1 ratio, and we are allowed to resize the hash
	     * table (global setting) or we should avoid it but the ratio between
	     * elements/</span><span class="n">buckets</span> <span class="n">is</span> <span class="n">over</span> <span class="n">the</span> <span class="s2">"safe"</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">we</span> <span class="n">resize</span> <span class="n">doubling</span>
	     <span class="o">*</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">buckets</span><span class="p">.</span> <span class="nf">*</span><span class="o">/</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">used</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">size</span> <span class="o">&amp;&amp;</span>
	        <span class="p">(</span><span class="n">dict_can_resize</span> <span class="o">||</span>
	         <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">used</span><span class="o">/</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">size</span> <span class="o">&gt;</span> <span class="n">dict_force_resize_ratio</span><span class="p">))</span>
	    <span class="p">{</span>
	        <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">used</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
	    <span class="p">}</span>
	    <span class="k">return</span> <span class="no">DICT_OK</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>从代码中可以看出：</p>

<ul>
  <li>当负载因子(load factor)达到 1 时，如果允许扩展(<code class="highlighter-rouge">dict_can_resize</code>设置为1)，就进行扩展操作</li>
  <li>当负载因子超过安全阈值 <code class="highlighter-rouge">dict_force_resize_ratio</code>时，就会强制进行扩展</li>
</ul>

<h3 id="收缩">收缩</h3>
<p>当哈希表节点数减少时，为了保证 load factor 在一个合理范围内，需要对哈希表进行收缩，当负载因子小于等于 1 时，就需要做这种操作。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Resize the table to the minimal size that contains all the elements,
 * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */
int dictResize(dict *d)
{
    int minimal;

    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;
    minimal = d-&gt;ht[0].used;
    if (minimal &lt; DICT_HT_INITIAL_SIZE)
        minimal = DICT_HT_INITIAL_SIZE;
    return dictExpand(d, minimal);
}
</code></pre></div></div>

<h3 id="哈希表调整大小的计算">哈希表调整大小的计算</h3>
<p>哈希表进行扩展或者收缩，新的哈希大小是如何计算的呢</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Our hash table capability is a power of two */
static unsigned long _dictNextPower(unsigned long size)
{
    unsigned long i = DICT_HT_INITIAL_SIZE;

    if (size &gt;= LONG_MAX) return LONG_MAX;
    while(1) {
        if (i &gt;= size)
            return i;
        i *= 2;
    }
} `DICT_HT_INITAL_SIZE`的值为4，即 2^2，所以每次设置的新哈希表的大小均为 2 的 n 次幂。
</code></pre></div></div>

<h3 id="渐进式-rehash">渐进式 rehash</h3>
<p>哈希表 rehash 操作时将 ht[0] 中的所有键值对 rehash 到 ht[1] 中，但是这个动作并不是一次性、集中式的完成的，而是渐进式的、分多次完成的。因为当键值对数量很大时，集中式的 rehash 操作，需要庞大的计算量，可能会导致服务器在一段时间内停止服务。为了避免 rehash 对服务器性能造成影响，所以将 rehash 操作分多次执行，渐进式的操作。</p>

<p>1) 当需要 rehash 时，将 rehashidx 设置为0 <br />
2) 为 ht[1] 分配空间，此时字典同时拥有 ht[0] 和 ht[1] 两个哈希表 <br />
3) 在 rehash 期间，通过判断 rehashidx 是否等于 -1，每次对字典进程添加、删除、查找和更新操作时，出了执行指定操作之外，还会将 <code class="highlighter-rouge">ht[0].table[rehashidx]</code> 这个单链表上的所有键值对 rehash 到 ht[1] 中，操作完成后，将 rehashidx 加 1 <br />
4) 当 rehash 操作完成后，rehashidx 的值被设置为 -1</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* Performs N steps of incremental rehashing. Returns 1 if there are still
	 * keys to move from the old to the new hash table, otherwise 0 is returned.
	 *
	 * Note that a rehashing step consists in moving a bucket (that may have more
	 * than one key as we use chaining) from the old to the new hash table, however
	 * since part of the hash table may be composed of empty spaces, it is not
	 * guaranteed that this function will rehash even a single bucket, since it
	 * will visit at max N*10 empty buckets in total, otherwise the amount of
	 * work it does would be unbound and the function may block for a long time. */</span>
	<span class="sr">//</span> <span class="err">返回</span><span class="mi">0</span><span class="err">表示</span> <span class="n">rehash</span> <span class="err">结束，返回</span><span class="mi">1</span> <span class="err">表示还有键值对需要继续</span> <span class="n">rehash</span> 
	<span class="n">int</span> <span class="n">dictRehash</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">int</span> <span class="n">empty_visits</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span> <span class="sr">/* Max number of empty buckets to visit. */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
	    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">used</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span> <span class="o">*</span><span class="n">nextde</span><span class="p">;</span>
	
	        <span class="sr">/* Note that rehashidx can't overflow as we are sure there are more
	         * elements because ht[0].used != 0 */</span>
	        <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">);</span>
	        <span class="k">while</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">]</span> <span class="o">==</span> <span class="no">NULL</span><span class="p">)</span> <span class="p">{</span>
	            <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="o">++</span><span class="p">;</span>
	            <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">empty_visits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	        <span class="p">}</span>
	        <span class="n">de</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">];</span>
	        <span class="sr">/* Move all the keys in this bucket from the old to the new hash HT */</span>
	        <span class="k">while</span><span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
	            <span class="n">unsigned</span> <span class="n">int</span> <span class="n">h</span><span class="p">;</span>
	
	            <span class="n">nextde</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="k">next</span><span class="p">;</span>
	            <span class="sr">/* Get the index in the new hash table */</span>
	            <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">sizemask</span><span class="p">;</span>
	            <span class="n">de</span><span class="o">-&gt;</span><span class="k">next</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">table</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
	            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">table</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">de</span><span class="p">;</span>
	            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">used</span><span class="o">--</span><span class="p">;</span>
	            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">used</span><span class="o">++</span><span class="p">;</span>
	            <span class="n">de</span> <span class="o">=</span> <span class="n">nextde</span><span class="p">;</span>
	        <span class="p">}</span>
	        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">]</span> <span class="o">=</span> <span class="no">NULL</span><span class="p">;</span>
	        <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="o">++</span><span class="p">;</span>		<span class="sr">//</span><span class="err">操作完将</span> <span class="n">rehashidx</span> <span class="err">加</span><span class="mi">1</span>
	    <span class="p">}</span>
	
	    <span class="sr">/* Check if we already rehashed the whole table... */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="sr">//</span><span class="err">判断是否</span> <span class="n">rehash</span> <span class="err">操作完成</span>
	        <span class="n">zfree</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">table</span><span class="p">);</span>
	        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	        <span class="n">_dictReset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	        <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="p">}</span>
	
	    <span class="sr">/* More to rehash... */</span>
	    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<h2 id="哈希操作">哈希操作</h2>
<h3 id="查找操作">查找操作</h3>
<p>查找操作，当 rehashidx 的值不等于 -1 时，说明正在 rehash，那么进行一次rehash操作，在 <code class="highlighter-rouge">_dictRehashStep(d)</code>中调用 <code class="highlighter-rouge">dictRehash(d, 1)</code>执行一次。</p>

<p>查找时，在 ht[0] 和 ht[1] 中都需要查找</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dictEntry *dictFind(dict *d, const void *key)
{
    dictEntry *he;
    unsigned int h, idx, table;

    if (d-&gt;ht[0].size == 0) return NULL; /* We don't have a table at all */
    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);
    for (table = 0; table &lt;= 1; table++) {
        idx = h &amp; d-&gt;ht[table].sizemask;
        he = d-&gt;ht[table].table[idx];
        while(he) {
            if (dictCompareKeys(d, key, he-&gt;key))
                return he;
            he = he-&gt;next;
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}
</code></pre></div></div>

<h3 id="添加">添加</h3>
<p>添加操作在上文中<strong>解决键冲突</strong>一节已经介绍了。</p>
<h3 id="删除">删除</h3>
<p>删除操作，先在哈希表中查找指定 value 的键值对，然后删除。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="n">int</span> <span class="n">dictDelete</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">return</span> <span class="n">dictGenericDelete</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="sr">/* Search and remove an element */</span>
	<span class="n">static</span> <span class="n">int</span> <span class="n">dictGenericDelete</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">int</span> <span class="n">nofree</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="n">unsigned</span> <span class="n">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>
	    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">he</span><span class="p">,</span> <span class="o">*</span><span class="n">prevHe</span><span class="p">;</span>
	    <span class="n">int</span> <span class="n">table</span><span class="p">;</span>
	
	    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="no">DICT_ERR</span><span class="p">;</span> <span class="sr">/* d-&gt;ht[0].table is NULL */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="n">_dictRehashStep</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	    <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>	<span class="sr">//</span><span class="err">获取哈希值</span>
	
	    <span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">table</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">idx</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="nf">sizemask</span><span class="p">;</span>	<span class="sr">//</span><span class="err">计算索引值</span>
	        <span class="n">he</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="nf">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	        <span class="n">prevHe</span> <span class="o">=</span> <span class="no">NULL</span><span class="p">;</span>
	        <span class="k">while</span><span class="p">(</span><span class="n">he</span><span class="p">)</span> <span class="p">{</span>
	            <span class="k">if</span> <span class="p">(</span><span class="n">dictCompareKeys</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>	<span class="sr">//</span><span class="err">找到了</span>
	                <span class="sr">/* Unlink the element from the list */</span>
	                <span class="k">if</span> <span class="p">(</span><span class="n">prevHe</span><span class="p">)</span>	<span class="o">/</span><span class="sr">/从单链表中删除该节点
	                    prevHe-&gt;next = he-&gt;next;
	                else
	                    d-&gt;ht[table].table[idx] = he-&gt;next;
	                if (!nofree) {
	                    dictFreeKey(d, he);
	                    dictFreeVal(d, he);
	                }
	                zfree(he);
	                d-&gt;ht[table].used--;
	                return DICT_OK;
	            }
	            prevHe = he;
	            he = he-&gt;next;
	        }
	        if (!dictIsRehashing(d)) break;
	    }
	    return DICT_ERR; /</span><span class="o">*</span> <span class="n">not</span> <span class="n">found</span> <span class="o">*</span><span class="sr">/
	}</span></code></pre></figure>

<h3 id="更新">更新</h3>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* Add an element, discarding the old if the key already exists.
	 * Return 1 if the key was added from scratch, 0 if there was already an
	 * element with such key and dictReplace() just performed a value update
	 * operation. */</span>
	<span class="n">int</span> <span class="n">dictReplace</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">auxentry</span><span class="p">;</span>
	
	    <span class="sr">/* Try to add the element. If the key
	     * does not exists dictAdd will suceed. */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">dictAdd</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="no">DICT_OK</span><span class="p">)</span>
	        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	    <span class="sr">/* It already exists, get the entry */</span>
	    <span class="n">entry</span> <span class="o">=</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	    <span class="sr">/* Set the new value and free the old one. Note that it is important
	     * to do that in this order, as the value may just be exactly the same
	     * as the previous one. In this context, think to reference counting,
	     * you want to increment (set), and then decrement (free), and not the
	     * reverse. */</span>
	    <span class="n">auxentry</span> <span class="o">=</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	    <span class="n">dictSetVal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	    <span class="n">dictFreeVal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">auxentry</span><span class="p">);</span>
	    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p><strong>参考文献：</strong> <br /></p>
<ol>
  <li>Redis设计与实现，黄健宏 <br /></li>
  <li>博客文章[http://blog.csdn.net/androidlushangderen/article/details/39860693]</li>
</ol>
