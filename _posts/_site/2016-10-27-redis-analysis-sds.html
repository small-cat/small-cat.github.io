<p>redis中简单动态字符串 sds 分析</p>

<blockquote>
  <p>参考书籍： <br />
Redis设计与实现 (The Design and Implementation of Redis)，黄建宏著。<br />
推荐安卓路上的人（Androidlushangderen）的博客专栏: 
http://blog.csdn.net/column/details/redis-code.html</p>
</blockquote>

<p>redis 使用的字符串抽象数据类型为 SDS (simple dynamic string)。其结构如下所示：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct sdshdr {
	unsigned int len;	//表示字符串长度，即字符数组buf已使用的长度
	unsigned int free;	//表示buf 数组中尚未使用的字节数
	char buf[];		//保存字符串，这是一个可变数组
};
</code></pre></div></div>

<p><strong>上述结构属于C99中的伸缩数组(flexible array)，是对结构体功能的扩展。在结构体的原型申明时，可以申明一个没有指定数组长度的数组，在使用是，通过malloc动态决定结构体变量的数组大小。</strong></p>

<p>sds 不同于传统的 C 字符串，它的好处显而易见。</p>

<p>1、 能够在常数复杂度内获取字符串的长度，直接返回 len 就可以了。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static inline size_t sdslen(const sds s) {
	struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));		//sds s = sdsnew创建的,返回的是
				//struct sdshdr *shnew-&gt;buf，往后偏移了8个字节，这里往前偏移8个字节
	return sh-&gt;len;
}
</code></pre></div></div>

<p>其中的 sds 的定义为</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef char* sds; 因为 sdshdr 的 buf 成员是可变长数组， sizeof 是得不到长度的，所以sizeof(sdshdr)为8，每次创建 sdshdr结构体的时候，返回的都是buf这个字符串，即指针位置向后移动了 sizeof (sdshdr)这个长度，所以在上面由字符串获取 sdshdr 结构体的地址的时候，再往前偏移 sizeof (sdshdr) 个地址，然后直接获取长度 len
</code></pre></div></div>

<p>2、 sds 所有API均是二进制安全的，在 sdsnewlen 函数的注释中，有这么一段注释</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> * You can print the string with printf() as there is an implicit \0 at the
 * end of the string. However the string is binary safe and can contain
 * \0 characters in the middle, as the length is stored in the sds header.
</code></pre></div></div>

<p>sds 字符串的末尾有一个 ‘\0’ 结尾，作为字符串的结尾，但是为了适应各种类型的数据，同时，还是二进制安全的，在buf 的中间是可以有 ‘\0’ 空字符的，因为取数据不是按照字符串的结尾空字符，而是根据 sdshdr 结构体中的 len 长度来获取的。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="n">sds</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">initlen</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">struct</span> <span class="n">sdshdr</span> <span class="o">*</span><span class="n">sh</span><span class="p">;</span>
	
	    <span class="k">if</span> <span class="p">(</span><span class="n">init</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">sh</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)</span><span class="o">+</span><span class="n">initlen</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>	<span class="sr">//</span><span class="err">申请内存</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	        <span class="n">sh</span> <span class="o">=</span> <span class="n">zcalloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)</span><span class="o">+</span><span class="n">initlen</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	    <span class="p">}</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="no">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="no">NULL</span><span class="p">;</span>
	    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">initlen</span><span class="p">;</span>
	    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="sr">//</span><span class="err">因为新申请的</span><span class="n">sds</span><span class="err">，所以</span><span class="n">free</span><span class="err">设置为</span><span class="mi">0</span><span class="err">，在重新调整时，会增加</span><span class="n">free</span><span class="err">的长度</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">initlen</span> <span class="o">&amp;&amp;</span> <span class="n">init</span><span class="p">)</span>
	        <span class="n">memcpy</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">initlen</span><span class="p">);</span>
	    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">initlen</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'\0'</span><span class="p">;</span>
	    <span class="k">return</span> <span class="p">(</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>	<span class="sr">//</span><span class="err">返回</span> <span class="n">sds</span> <span class="err">字符串</span>
	<span class="p">}</span></code></pre></figure>

<p>3、 杜绝缓冲区溢出，减少修改字符串带来的内存重复分配的次数 <br />
sds 在调用 sdscat等字符串拼接类的API时，都会调整空间大小，即增加free的大小，保证不会发生缓冲区溢出</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">//</span><span class="err">这个函数不会改变字符串的值，也不会改变</span><span class="n">len</span> <span class="err">的长度，只是增加了</span><span class="n">free</span><span class="err">的大小</span>
	<span class="n">sds</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">sds</span> <span class="n">s</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">addlen</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">struct</span> <span class="n">sdshdr</span> <span class="o">*</span><span class="n">sh</span><span class="p">,</span> <span class="o">*</span><span class="n">newsh</span><span class="p">;</span>
	    <span class="n">size_t</span> <span class="n">free</span> <span class="o">=</span> <span class="n">sdsavail</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	    <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">newlen</span><span class="p">;</span>
	
	    <span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">addlen</span><span class="p">)</span> <span class="k">return</span> <span class="n">s</span><span class="p">;</span>	<span class="sr">//</span><span class="err">当剩余空间充足时，不需要调整</span>
	    <span class="n">len</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	    <span class="n">sh</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)));</span>
	    <span class="n">newlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="n">addlen</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">newlen</span> <span class="o">&lt;</span> <span class="no">SDS_MAX_PREALLOC</span><span class="p">)</span>	<span class="o">/</span><span class="sr">/1024*1024，就是1M
	        newlen *= 2;
	    else
	        newlen += SDS_MAX_PREALLOC;
	    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);
	    if (newsh == NULL) return NULL;
	
	    newsh-&gt;free = newlen - len;
	    return newsh-&gt;buf;
	}</span></code></pre></figure>

<p>调整sds 的空间大小时， 如果执行的是拼接字符串操作，长度为 addlen，那么先判断剩余可分配内存的大小 free，如果空间足够，不需要调整，否则，当 newlen 小于 1M 时，增加newlen 的一倍，拼接后，free 的长度同样为newlen，否则，增加 1M的长度。</p>

<p>而且sds采用的是惰性空间释放策略，并不是真正的释放内存空间</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="n">sds</span> <span class="n">sdstrim</span><span class="p">(</span><span class="n">sds</span> <span class="n">s</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">cset</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">struct</span> <span class="n">sdshdr</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)));</span>
	    <span class="n">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="k">end</span><span class="p">,</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	    <span class="n">size_t</span> <span class="n">len</span><span class="p">;</span>
	
	    <span class="n">sp</span> <span class="o">=</span> <span class="n">start</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	    <span class="n">ep</span> <span class="o">=</span> <span class="k">end</span> <span class="o">=</span> <span class="n">s</span><span class="o">+</span><span class="n">sdslen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	    <span class="k">while</span><span class="p">(</span><span class="n">sp</span> <span class="o">&lt;=</span> <span class="k">end</span> <span class="o">&amp;&amp;</span> <span class="n">strchr</span><span class="p">(</span><span class="n">cset</span><span class="p">,</span> <span class="o">*</span><span class="n">sp</span><span class="p">))</span> <span class="n">sp</span><span class="o">++</span><span class="p">;</span>
	    <span class="k">while</span><span class="p">(</span><span class="n">ep</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">strchr</span><span class="p">(</span><span class="n">cset</span><span class="p">,</span> <span class="o">*</span><span class="n">ep</span><span class="p">))</span> <span class="n">ep</span><span class="o">--</span><span class="p">;</span>
	    <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;</span> <span class="n">ep</span><span class="p">)</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">((</span><span class="n">ep</span><span class="o">-</span><span class="n">sp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">!=</span> <span class="n">sp</span><span class="p">)</span> <span class="n">memmove</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'\0'</span><span class="p">;</span>
	    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span><span class="o">+</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">-</span><span class="n">len</span><span class="p">);</span>
	    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>仅仅是将增加free的长度，并将buf 和len的值进行调整，这样，当下一次对该 sds 进行字符串拼接的操作时，不需要频繁重复的申请空间，减少了内存申请的次数。</p>

<p>sds 具有以下优点：</p>

<ul>
  <li>常熟复杂度获取字符串长度</li>
  <li>杜绝缓冲区溢出</li>
  <li>减少修改字符串长度时所需的内存重分配次数</li>
  <li>二进制安全</li>
  <li>兼容部分C函数。</li>
</ul>

<p>其他的相关API函数解析</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* Helper for sdscatlonglong() doing the actual number -&gt; string
	 * conversion. 's' must point to a string with room for at least
	 * SDS_LLSTR_SIZE bytes.
	 *
	 * The function returns the length of the null-terminated string
	 * representation stored at 's'. */</span>
	<span class="c1">#define SDS_LLSTR_SIZE 21	//long long类型的最大数为 9223372036854775808 = 2^63,而 2^64有20位</span>
	<span class="sr">//</span> <span class="n">long</span> <span class="n">long</span> <span class="n">convert</span> <span class="n">to</span> <span class="n">string</span><span class="p">,</span> <span class="k">return</span> <span class="n">length</span> <span class="n">of</span> <span class="n">string</span>
	<span class="n">int</span> <span class="n">sdsll2str</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">long</span> <span class="n">long</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">char</span> <span class="o">*</span><span class="nb">p</span><span class="p">,</span> <span class="n">aux</span><span class="p">;</span>
	    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="n">v</span><span class="p">;</span>
	    <span class="n">size_t</span> <span class="n">l</span><span class="p">;</span>
	
	    <span class="sr">/* Generate the string representation, this method produces
	     * an reversed string. */</span>
	    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">?</span> <span class="o">-</span><span class="n">value</span> <span class="p">:</span> <span class="n">value</span><span class="p">;</span>
	    <span class="nb">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	    <span class="k">do</span> <span class="p">{</span>
	        <span class="o">*</span><span class="nb">p</span><span class="o">++</span> <span class="o">=</span> <span class="s1">'0'</span><span class="o">+</span><span class="p">(</span><span class="n">v</span><span class="o">%</span><span class="mi">10</span><span class="p">);</span>	<span class="sr">//</span><span class="err">逐位求余</span>
	        <span class="n">v</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
	    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span><span class="nb">p</span><span class="o">++</span> <span class="o">=</span> <span class="s1">'-'</span><span class="p">;</span>
	
	    <span class="sr">/* Compute length and add null term. */</span>
	    <span class="n">l</span> <span class="o">=</span> <span class="nb">p</span><span class="o">-</span><span class="n">s</span><span class="p">;</span>
	    <span class="o">*</span><span class="nb">p</span> <span class="o">=</span> <span class="s1">'\0'</span><span class="p">;</span>
	
	    <span class="sr">/* Reverse the string. */</span>
	    <span class="nb">p</span><span class="o">--</span><span class="p">;</span>
	    <span class="k">while</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="nb">p</span><span class="p">)</span> <span class="p">{</span>	<span class="sr">//</span><span class="err">倒序，因为</span><span class="n">long</span> <span class="n">long</span><span class="err">的最高数字在</span><span class="n">p</span><span class="err">的第一个字符位置</span>
	        <span class="n">aux</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	        <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">*</span><span class="nb">p</span><span class="p">;</span>
	        <span class="o">*</span><span class="nb">p</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>
	        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
	        <span class="nb">p</span><span class="o">--</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>	<span class="sr">//</span><span class="err">返回转换后的字符串的长度</span>
	<span class="p">}</span></code></pre></figure>

<p>格式化输出函数 sdscatfmt，比sdscatprintf 性能好，因为后者依赖于libc 中的 sprintf() 家族，这种会比较慢，同时直接操作 sds 字符串性能会更好</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* This function is similar to sdscatprintf, but much faster as it does
	 * not rely on sprintf() family functions implemented by the libc that
	 * are often very slow. Moreover directly handling the sds string as
	 * new data is concatenated provides a performance improvement.
	 *
	 * However this function only handles an incompatible subset of printf-alike
	 * format specifiers:
	 *
	 * %s - C String
	 * %S - SDS string
	 * %i - signed int
	 * %I - 64 bit signed integer (long long, int64_t)
	 * %u - unsigned int
	 * %U - 64 bit unsigned integer (unsigned long long, uint64_t)
	 * %% - Verbatim "%" character.
	 */</span>
	<span class="n">sds</span> <span class="n">sdscatfmt</span><span class="p">(</span><span class="n">sds</span> <span class="n">s</span><span class="p">,</span> <span class="n">char</span> <span class="n">const</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">struct</span> <span class="n">sdshdr</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)));</span>
	    <span class="n">size_t</span> <span class="n">initlen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	    <span class="n">int</span> <span class="n">i</span><span class="p">;</span>
	    <span class="n">va_list</span> <span class="n">ap</span><span class="p">;</span>
	
	    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">fmt</span><span class="p">);</span>
	    <span class="n">f</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>    <span class="sr">/* Next format specifier byte to process. */</span>
	    <span class="n">i</span> <span class="o">=</span> <span class="n">initlen</span><span class="p">;</span> <span class="sr">/* Position of the next byte to write to dest str. */</span>
	    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">char</span> <span class="k">next</span><span class="p">,</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	        <span class="n">unsigned</span> <span class="n">int</span> <span class="n">l</span><span class="p">;</span>		<span class="sr">//</span><span class="o">%</span><span class="n">u</span>
	        <span class="n">long</span> <span class="n">long</span> <span class="n">num</span><span class="p">;</span>		<span class="sr">//</span><span class="o">%</span><span class="no">I</span>
	        <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="n">unum</span><span class="p">;</span>	<span class="sr">//</span><span class="o">%</span><span class="no">U</span>
	
	        <span class="sr">/* Make sure there is always space for at least 1 char. */</span>
	        <span class="k">if</span> <span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	            <span class="n">s</span> <span class="o">=</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>	<span class="sr">//</span><span class="err">调整</span><span class="n">free</span><span class="err">的大小，保证足够的空间</span>
	            <span class="n">sh</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)));</span>
	        <span class="p">}</span>
	
	        <span class="n">switch</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
	        <span class="k">case</span> <span class="s1">'%'</span><span class="p">:</span>
	            <span class="k">next</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	            <span class="n">f</span><span class="o">++</span><span class="p">;</span>
	            <span class="n">switch</span><span class="p">(</span><span class="k">next</span><span class="p">)</span> <span class="p">{</span>
	            <span class="k">case</span> <span class="s1">'s'</span><span class="p">:</span>
	            <span class="k">case</span> <span class="s1">'S'</span><span class="p">:</span>
	                <span class="n">str</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">char</span><span class="o">*</span><span class="p">);</span>
	                <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="k">next</span> <span class="o">==</span> <span class="s1">'s'</span><span class="p">)</span> <span class="p">?</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">:</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	                <span class="k">if</span> <span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
	                    <span class="n">s</span> <span class="o">=</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
	                    <span class="n">sh</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)));</span>
	                <span class="p">}</span>
	                <span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>		<span class="sr">//</span><span class="err">在当前字符串后面继续</span><span class="n">append</span>
	                <span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	                <span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
	                <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	                <span class="k">break</span><span class="p">;</span>
	            <span class="k">case</span> <span class="s1">'i'</span><span class="p">:</span>
	            <span class="k">case</span> <span class="s1">'I'</span><span class="p">:</span>
	                <span class="k">if</span> <span class="p">(</span><span class="k">next</span> <span class="o">==</span> <span class="s1">'i'</span><span class="p">)</span>
	                    <span class="n">num</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">int</span><span class="p">);</span>
	                <span class="k">else</span>
	                    <span class="n">num</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">long</span> <span class="n">long</span><span class="p">);</span>
	                <span class="p">{</span>
	                    <span class="n">char</span> <span class="n">buf</span><span class="p">[</span><span class="no">SDS_LLSTR_SIZE</span><span class="p">];</span>
	                    <span class="n">l</span> <span class="o">=</span> <span class="n">sdsll2str</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>		<span class="sr">//</span><span class="n">long</span> <span class="n">long</span> <span class="n">convert</span> <span class="n">to</span> <span class="n">string</span><span class="p">,</span> <span class="k">return</span> <span class="n">sds</span>
	                    <span class="k">if</span> <span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
	                        <span class="n">s</span> <span class="o">=</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
	                        <span class="n">sh</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)));</span>
	                    <span class="p">}</span>
	                    <span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
	                    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	                    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
	                    <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	                <span class="p">}</span>
	                <span class="k">break</span><span class="p">;</span>
	            <span class="k">case</span> <span class="s1">'u'</span><span class="p">:</span>
	            <span class="k">case</span> <span class="s1">'U'</span><span class="p">:</span>
	                <span class="k">if</span> <span class="p">(</span><span class="k">next</span> <span class="o">==</span> <span class="s1">'u'</span><span class="p">)</span>
	                    <span class="n">unum</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">unsigned</span> <span class="n">int</span><span class="p">);</span>
	                <span class="k">else</span>
	                    <span class="n">unum</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span><span class="p">);</span>
	                <span class="p">{</span>
	                    <span class="n">char</span> <span class="n">buf</span><span class="p">[</span><span class="no">SDS_LLSTR_SIZE</span><span class="p">];</span>
	                    <span class="n">l</span> <span class="o">=</span> <span class="n">sdsull2str</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">unum</span><span class="p">);</span>
	                    <span class="k">if</span> <span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
	                        <span class="n">s</span> <span class="o">=</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
	                        <span class="n">sh</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sdshdr</span><span class="p">)));</span>
	                    <span class="p">}</span>
	                    <span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
	                    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	                    <span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
	                    <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	                <span class="p">}</span>
	                <span class="k">break</span><span class="p">;</span>
	            <span class="ss">default: </span><span class="sr">/* Handle %% and generally %&lt;unknown&gt;. */</span>
	                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="k">next</span><span class="p">;</span>
	                <span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	                <span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	                <span class="k">break</span><span class="p">;</span>
	            <span class="p">}</span>
	            <span class="k">break</span><span class="p">;</span>
	        <span class="ss">default:	</span><span class="sr">//</span><span class="err">不是</span> <span class="o">%</span> <span class="err">时，直接将字符放在</span> <span class="n">s</span> <span class="err">中</span>
	            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	            <span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	            <span class="n">sh</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	            <span class="k">break</span><span class="p">;</span>
	        <span class="p">}</span>
	        <span class="n">f</span><span class="o">++</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	
	    <span class="sr">/* Add null-term */</span>
	    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'\0'</span><span class="p">;</span>
	    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>上述这个函数的完整写法可以借鉴，当需要自己处理格式化字符串的时候，libc 提供的格式化字符串的函数 sprintf… 会对性能有一定的影响。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="sr">/* Split 's' with separator in 'sep'. An array
	 * of sds strings is returned. *count will be set
	 * by reference to the number of tokens returned.
	 *
	 * On out of memory, zero length string, zero length
	 * separator, NULL is returned.
	 *
	 * Note that 'sep' is able to split a string using
	 * a multi-character separator. For example
	 * sdssplit("foo_-_bar","_-_"); will return two
	 * elements "foo" and "bar".
	 *
	 * This version of the function is binary-safe but
	 * requires length arguments. sdssplit() is just the
	 * same function but for zero-terminated strings.
	 */</span>
	<span class="sr">//</span> <span class="err">函数功能：</span> <span class="err">将字符串</span> <span class="n">s</span> <span class="err">以</span> <span class="n">sep</span> <span class="err">分割，并将分割后的结果保存在</span> <span class="n">token</span> <span class="err">数组中</span>
	<span class="sr">//</span> <span class="n">sep</span> <span class="err">可以使单个分割字符</span> <span class="err">，也可以是一个字符串</span>
	<span class="n">sds</span> <span class="o">*</span><span class="n">sdssplitlen</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span> <span class="n">int</span> <span class="n">seplen</span><span class="p">,</span> <span class="n">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">int</span> <span class="n">elements</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slots</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	    <span class="n">sds</span> <span class="o">*</span><span class="n">tokens</span><span class="p">;</span>
	
	    <span class="k">if</span> <span class="p">(</span><span class="n">seplen</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="no">NULL</span><span class="p">;</span>
	
	    <span class="n">tokens</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span><span class="o">*</span><span class="n">slots</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">tokens</span> <span class="o">==</span> <span class="no">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="no">NULL</span><span class="p">;</span>
	
	    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	        <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	        <span class="k">return</span> <span class="n">tokens</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len</span><span class="o">-</span><span class="p">(</span><span class="n">seplen</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	        <span class="sr">/* make sure there is room for the next element and the final one */</span>
	        <span class="k">if</span> <span class="p">(</span><span class="n">slots</span> <span class="o">&lt;</span> <span class="n">elements</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>	<span class="sr">//</span> <span class="err">默认的</span><span class="n">token</span> <span class="err">数组大小为</span><span class="mi">5</span>
	            <span class="n">sds</span> <span class="o">*</span><span class="n">newtokens</span><span class="p">;</span>
	
	            <span class="n">slots</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	            <span class="n">newtokens</span> <span class="o">=</span> <span class="n">zrealloc</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="n">sizeof</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span><span class="o">*</span><span class="n">slots</span><span class="p">);</span>
	            <span class="k">if</span> <span class="p">(</span><span class="n">newtokens</span> <span class="o">==</span> <span class="no">NULL</span><span class="p">)</span> <span class="n">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	            <span class="n">tokens</span> <span class="o">=</span> <span class="n">newtokens</span><span class="p">;</span>
	        <span class="p">}</span>
	        <span class="sr">/* search the separator */</span>
			<span class="sr">//</span> <span class="err">将</span> <span class="n">s</span> <span class="err">进行分割，然后保存在</span> <span class="n">token</span> <span class="err">中</span>
	        <span class="k">if</span> <span class="p">((</span><span class="n">seplen</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">sep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="n">sep</span><span class="p">,</span><span class="n">seplen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
	            <span class="n">tokens</span><span class="p">[</span><span class="n">elements</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">start</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>	<span class="sr">//</span> <span class="n">j</span><span class="o">-</span><span class="n">start</span> <span class="err">为分割后当前小串的长度</span>
	            <span class="k">if</span> <span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">elements</span><span class="p">]</span> <span class="o">==</span> <span class="no">NULL</span><span class="p">)</span> <span class="n">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	            <span class="n">elements</span><span class="o">++</span><span class="p">;</span>
	            <span class="n">start</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="n">seplen</span><span class="p">;</span>	<span class="sr">//</span><span class="err">跳过</span> <span class="n">sep</span><span class="err">，到下一个分割的小串的起始位置</span>
	            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="n">seplen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="sr">/* skip the separator */</span>
	        <span class="p">}</span>
	    <span class="p">}</span>
	    <span class="sr">/* Add the final element. We are sure there is room in the tokens array. */</span>
	    <span class="n">tokens</span><span class="p">[</span><span class="n">elements</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">start</span><span class="p">,</span><span class="n">len</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">elements</span><span class="p">]</span> <span class="o">==</span> <span class="no">NULL</span><span class="p">)</span> <span class="n">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	    <span class="n">elements</span><span class="o">++</span><span class="p">;</span>
	    <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">elements</span><span class="p">;</span>
	    <span class="k">return</span> <span class="n">tokens</span><span class="p">;</span>
	
	<span class="ss">cleanup:
	    </span><span class="p">{</span>
			<span class="sr">//</span> <span class="err">清空释放</span> <span class="n">token</span>
	        <span class="n">int</span> <span class="n">i</span><span class="p">;</span>
	        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">elements</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">sdsfree</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	        <span class="n">zfree</span><span class="p">(</span><span class="n">tokens</span><span class="p">);</span>
	        <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	        <span class="k">return</span> <span class="no">NULL</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span></code></pre></figure>
