<p>glibc 提供了运行库，提供了入口函数，下面我们自己来实现一个mini运行库。</p>

<h1 id="如何构建自己的运行库">如何构建自己的运行库</h1>

<p>之前介绍了<a href="http://blog.wuzhenyu.com.cn/2019/02/21/what-happened-before-and-after-main.html">《main函数之前后》</a>，这次，我们试图来构建一个自己的运行库。</p>

<blockquote>
  <p>本篇文章中的例子，来自于俞甲子、石凡、潘爱民的《程序员的自我修养-链接、装载与库》，对例子进行了更新，原书中是32位，这里是64位。也感谢这本书给我带来的帮助，对编译过程和程序的底层知识有了深一层的认识，而这篇文章也作为我的一个笔记和学习成果吧。</p>
</blockquote>

<p><a href="https://github.com/small-cat/myCode_repository/tree/master/minicrt/c"><strong>本文中的源代码地址</strong></a></p>

<p>废话不多说，我们实现的这个运行库，也叫作 minicrt。之前说过，main函数之前，入口函数需要完成各种初始化和准备工作，然后调用main主体函数，main函数结束时，在调用exit负责后续的清理工作。那么先确定我们这个minicrt的基本功能：</p>

<ul>
  <li>
    <p>具有自己的入口函数 <code class="highlighter-rouge">mini_crt_entry</code></p>
  </li>
  <li>
    <p>基本的进程退出相关操作 exit</p>
  </li>
  <li>
    <p>支持堆操作 malloc、free</p>
  </li>
  <li>
    <p>支持基本的文件操作 fopen, fwrite. fclose, fread, fseek</p>
  </li>
  <li>
    <p>支持基本的字符串操作 strcpy, strcmp, strlen</p>
  </li>
  <li>
    <p>支持基本的字符串格式化和输出操作 printf sprintf</p>
  </li>
  <li>
    <p>支持 atexit() 函数</p>
  </li>
</ul>

<p>简单起见，所有的申明都放在同一个头文件中 minicrt.h</p>

<h2 id="入口函数">入口函数</h2>

<p>入口函数名为<code class="highlighter-rouge">mini_crt_entry</code>，没有参数，也没有返回值，因为exit函数调用的时候，如果正常，函数会直接退出，不会回到入口函数继续执行并返回结果。同时，函数体内还需准备好程序运行的环境，包括main函数的命令行参数，初始化运行库，如堆、I/O等，结束部分主要负责清理程序运行资源。</p>

<p>main函数的两个参数为 argc， argv，argc是参数个数，argv是一个字符串数组，保存的是所有的命令参数。当进程被初始化时，它的堆栈中就保存着环境变量和传递给main函数的参数。汇编指令中，一般函数栈的开头都如下</p>

<pre><code class="language-assembly">push   %rbp
mov    %rsp,%rbp
sub    $0x20,%rsp
</code></pre>

<p>这样，将基址寄存器rbp保存下来，然后开辟了一个32字节的栈空间作为函数栈空间。所以说，栈顶寄存器 rsp 指向的位置，是即将初始化的栈空间的顶部，即 rbp 指向的位置。如果我们像下面这样执行函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mini_crt hello
</code></pre></div></div>

<p>命令行参数就是两个，<code class="highlighter-rouge">mini_crt</code> 和 <code class="highlighter-rouge">hello</code>，在栈空间初始化之前分布如下所示</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
rsp
2
argv[0]'s addr
argv[1]'s addr
...
地址从上往下是递增的，因为栈是往地址小的方向增长的
</code></pre></div></div>

<p>栈空间初始化之后，<code class="highlighter-rouge">push rbp</code>，然后<code class="highlighter-rouge">mov rsp, rbp</code>，此时，rbp 的值就成了之前的 rsp，也就是说，rbp+8的值就是2，rbp+16的值就是argv的首地址了（我的环境是64位elementary os）。</p>

<p>完成了获取命令行参数的代码后，还需要在入口函数体内实现对堆和 I/O 的初始化，分别申明为 <code class="highlighter-rouge">mini_crt_heap_init</code>和 <code class="highlighter-rouge">mini_crt_io_init</code>。然后调用main主体函数，main函数返回时，调用exit函数退出。exit函数完成两个任务，一个是调用由 atexit() 函数注册的退出回调函数，另一个就是结束进程。入口函数代码如下</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">mini_crt_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">;</span>
     
    <span class="kt">char</span><span class="o">*</span> <span class="n">ebp_reg</span><span class="p">;</span>
    <span class="c1">//ebp_reg = %ebp
</span>    <span class="n">asm</span><span class="p">(</span>
            <span class="s">"mov %%rbp, %0 </span><span class="se">\t\n</span><span class="s">"</span>
            <span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">ebp_reg</span><span class="p">)</span>
       <span class="p">);</span>
     
    <span class="c1">// 64bit, the size of rbp is 8 bytes.
</span>    <span class="n">argc</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">ebp_reg</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">argv</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="p">)(</span><span class="n">ebp_reg</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
     
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mini_crt_heap_init</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">crt_fatal_error</span><span class="p">(</span><span class="s">"heap initialize failed."</span><span class="p">);</span>
    <span class="p">}</span>
     
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mini_crt_io_init</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">crt_fatal_error</span><span class="p">(</span><span class="s">"IO initialize failed."</span><span class="p">);</span>
    <span class="p">}</span>
     
    <span class="c1">// call main functions, and deliver the command line args.
</span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* system call number of sys_exit is 60 */</span>
<span class="kt">void</span> <span class="nf">exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">exitCode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">asm</span><span class="p">(</span>
            <span class="s">"mov $0x3c, %%rax </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %0, %%rdi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"syscall </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="o">::</span><span class="s">"m"</span><span class="p">(</span><span class="n">exitCode</span><span class="p">)</span>
       <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>exit 函数，使用系统调用退出，64位系统调用，统一使用 <code class="highlighter-rouge">syscall</code>，不是32位的 <code class="highlighter-rouge">int 0x08h</code>。64位的系统调用号也与32位不同，<code class="highlighter-rouge">sys_exit</code>的系统调用号为60，将 rax 寄存器的值设置为 60，rdi 为返回值，syscall 调用系统调用。</p>

<h2 id="堆的实现">堆的实现</h2>

<p>堆是一块巨大的内存空间，在这部分空间内，程序可以请求一块连续的内存并自由的使用，这块内存在程序主动放弃之前都会一直保持。如果进程的内存管理由操作系统的内核来做，那么就是说，每次程序申请堆空间，操作系统都要调用系统调用分配一块足够大的内存，给用户程序，从用户态切换到内核态，再切换到用户态，这样非常影响程序的性能。比较好的做法就是程序直接想操作系统一次申请一块适当大的空间，然后有程序自己管理这部分空间，当需要申请内存的时候，程序就成这块空间中切分一块，如果释放，就合并到这块空间中。所以，一般管理对空间分配的都是程序的运行库。</p>

<p>linux 提供了两个系统调用，brk/sbrk 和 mmap 来管理堆空间。在运行库中，有两种最基本的方法来管理堆空间的分配，一个是空闲链表法，一个是位图法。</p>

<p><strong>空闲链表法</strong>，是将堆中各个空闲块按照链表的方式连接起来，链表采用双向链表的方式，当程序申请空间时，从前往后遍历链表，找到一个合适大小的块分配给程序，当释放空间是，将这块不再使用的空间加入到链表中，然后查看前后是否也是空闲块，如果是，将空闲块合并成一块，减少空间碎片化。当然，实际堆管理比这复杂的多，这这是简单说明一下原理。</p>

<p><strong>位图法</strong>，是将整个空间划分成大量大小相等的块，用户请求内存的时候，分配整数个数的块给用户。第一块成为头Head，其余成为主体Body，未使用的为Free，所有使用两位即可表示一个块的使用情况，使用一个整数数组就能记录块的使用情况。</p>

<p>这里我们采用双链表的方式，来管理堆空间分配。</p>

<h3 id="实现">实现</h3>

<ul>
  <li>
    <p>采用空闲链表法管理堆分配</p>
  </li>
  <li>
    <p>堆大小固定为 32MB，然后在这 32MB 中进行空间管理。（仅学习demo使用，尽量简单）</p>
  </li>
  <li>
    <p>使用 brk 系统调用获取 32MB 空间</p>
  </li>
</ul>

<blockquote>
  <p>注意，由 brk/sbrk 分配的空间，仅仅只是虚拟地址空间，一开始是不会分配物理内存的，只有当进程试图访问某一个地址的时候，操作系统检测到访问异常，然后为被访问地址所在的页分配物理内存页</p>
</blockquote>

<p>先确定链表的结构体</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_heap_header</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span>
        <span class="n">HEAP_BLOCK_FREE</span> <span class="o">=</span> <span class="mh">0xABABABAB</span><span class="p">,</span>   <span class="c1">//magic number of free block
</span>        <span class="n">HEAP_BLOCK_USED</span> <span class="o">=</span> <span class="mh">0xCDCDCDCD</span>   <span class="c1">//magic number of used block
</span>    <span class="p">}</span><span class="n">type</span><span class="p">;</span>
 
    <span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_heap_header</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_heap_header</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">}</span> <span class="n">heap_header</span><span class="p">;</span>
                                                                                                                                                                          
<span class="cp">#define ADDR_ADD(a, o) (((char*)(a)) + o)
#define HEADER_SIZE (sizeof(heap_header))
</span></code></pre></div></div>

<p>结构体type表示块的状态，是否使用，size为块的大小，next 和 prev 表示双链表节点向前和向后的指针。宏函数 <code class="highlighter-rouge">ADDR_ADD(a, o)</code> 获取结构体的实际使用内存地址。o 表示 <code class="highlighter-rouge">HEADER_SIZE</code>时，指针往后偏移，跳过结构体节点的头部，后面的空间就是能够供程序直接使用的空间大小。</p>

<p>brk函数通过 <code class="highlighter-rouge">sys_brk</code>系统调用来实现</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">brk</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">end_data_segment</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Linux brk system call
</span>    <span class="c1">// sys_brk system call number: 12
</span>    <span class="c1">// rax:12, rdi:end_data_segment
</span>    <span class="n">asm</span> <span class="p">(</span>
            <span class="s">"mov $12, %%rax </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %1, %%rdi  </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"syscall        </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="o">:</span><span class="s">"b"</span><span class="p">(</span><span class="n">end_data_segment</span><span class="p">)</span>
        <span class="p">);</span>
    
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span> 
 
<span class="kt">int</span> <span class="nf">mini_crt_heap_init</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">heap_header</span><span class="o">*</span> <span class="n">header</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 
    <span class="c1">// 32MB heap size
</span>    <span class="kt">unsigned</span> <span class="n">heap_size</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">brk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">end</span> <span class="o">=</span> <span class="n">ADDR_ADD</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">heap_size</span><span class="p">);</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">brk</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
                                                                                                                                                                          
    <span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_header</span><span class="o">*</span><span class="p">)</span><span class="n">base</span><span class="p">;</span>
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">heap_size</span><span class="p">;</span>
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">HEAP_BLOCK_FREE</span><span class="p">;</span>
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">list_head</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">mini_crt_heap_init</code> 函数中，通过 brk 函数申请了32MB的空间，同时初始化和加入空闲链表作为第一个链表节点。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">heap_header</span><span class="o">*</span> <span class="n">header</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">header</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">;</span>     <span class="c1">//global static variable will be initialized at other place.
</span>    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">header</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">HEAP_BLOCK_USED</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
 
        <span class="k">if</span> <span class="p">((</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">size</span> <span class="o">+</span> <span class="n">HEADER_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">HEADER_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// header is apt 
</span>            <span class="n">header</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">HEAP_BLOCK_USED</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">ADDR_ADD</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">HEADER_SIZE</span><span class="p">);</span>
        <span class="p">}</span>
 
        <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">size</span> <span class="o">+</span> <span class="n">HEADER_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// block is too big, split into two parts.
</span>            <span class="n">heap_header</span><span class="o">*</span> <span class="n">split_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_header</span><span class="o">*</span><span class="p">)</span><span class="n">ADDR_ADD</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="n">HEADER_SIZE</span><span class="p">);</span>
            <span class="n">split_next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
            <span class="n">split_next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">split_next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">split_next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">split_next</span><span class="p">;</span>
 
            <span class="n">split_next</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">HEADER_SIZE</span><span class="p">);</span>
            <span class="n">split_next</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">HEAP_BLOCK_FREE</span><span class="p">;</span>
            <span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">HEADER_SIZE</span><span class="p">;</span>
            <span class="n">header</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">HEAP_BLOCK_USED</span><span class="p">;</span>
 
            <span class="k">return</span> <span class="n">ADDR_ADD</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">HEADER_SIZE</span><span class="p">);</span>
        <span class="p">}</span>                                                                                                                                                                 
        <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>malloc函数，从链表中遍历寻找合适大小的第一个块，如果块太大，就将块分割。返回NULL表示失败。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">heap_header</span><span class="o">*</span> <span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_header</span><span class="o">*</span><span class="p">)</span><span class="n">ADDR_ADD</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">-</span><span class="n">HEADER_SIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">HEAP_BLOCK_USED</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">header</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">HEAP_BLOCK_FREE</span><span class="p">;</span>
    <span class="c1">//merge if prev or next is also free
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">==</span><span class="n">HEAP_BLOCK_FREE</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//merge with prev
</span>        <span class="n">header</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">header</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">==</span><span class="n">HEAP_BLOCK_FREE</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// merge with next
</span>        <span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
        <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>free 函数不是真的将块释放，仅仅改变块的状态，设置为未使用的状态，同时，如果前后有空闲的块，就一起合并。</p>

<h2 id="io-文件操作">IO 文件操作</h2>

<p>IO 就是对文件的操作，仅支持一下功能：</p>

<ul>
  <li>实现 fopen、fread、fwrite、fclose 和 fseek 函数</li>
  <li>不实现 buffer 缓冲机制</li>
  <li>支持三个标准输入输出 stdin、stdout、stderr</li>
  <li>使用内嵌汇编实现 open、read、write、close和 seek 系统调用</li>
  <li>fopen 支持 “r”、“w“、”+“和”a”的几种组合，不对文本模式和二进制模式进行区分</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*************************************************************************
	&gt; File Name: stdio.c
	&gt; Author: Jona
	&gt; Mail: mblrwuzy@gmail.com 
	&gt; Created Time: 2019-02-01 10:37:38
 ************************************************************************/</span>

<span class="cp">#include "minicrt.h"
</span>
<span class="kt">int</span> <span class="nf">mini_crt_io_init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//TODO
</span>    <span class="c1">//this is a very simple version, does not need to initalize
</span>    <span class="c1">//reverse
</span>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************************************************************* 
 * * FUNCTION NAME: open
 * * DESCRIPTION: open file and return file descriptor, implement read 
 * function by system call sys_open.
 * system call number: 2
 * * ARGS: 
 * rax - system call number 0x2
 * rdi - pathname
 * rsi - flags
 * rdx - mode
 * * RETURN VALUE: fd - file descriptor
 * * AUTHOR: Jona
 * * CREATE TIME: 2019-02-01 11:03 
*************************************************************************/</span> 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">asm</span> <span class="p">(</span>
            <span class="s">"mov $2, %%rax </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %1, %%rdi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %2, %%rsi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %3, %%rdx </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"syscall </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="o">:</span><span class="s">"m"</span><span class="p">(</span><span class="n">pathname</span><span class="p">),</span> <span class="s">"m"</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span> <span class="s">"m"</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************************************************************* 
 * * FUNCTION NAME: read
 * * DESCRIPTION: implement with system call sys_read
 * * ARGS: 
 * rax = 0x0
 * rdi = fd
 * rsi = buffer
 * rdx = size
 * * RETURN VALUE: 
 * * AUTHOR: Jona
 * * CREATE TIME: 2019-02-01 11:13 
*************************************************************************/</span> 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">asm</span> <span class="p">(</span>
            <span class="s">"mov $0, %%rax </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %1, %%rdi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %2, %%rsi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %3, %%rdx </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"syscall      </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="o">:</span><span class="s">"m"</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span> <span class="s">"m"</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">"m"</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************************************************************* 
 * * FUNCTION NAME: write
 * * DESCRIPTION: implement with system call sys_write
 * * ARGS: 
 * rax = 0x01
 * rdi = fd
 * rsi = buffer
 * rdx = size
 * * RETURN VALUE: 
 * * AUTHOR: Jona
 * * CREATE TIME: 2019-02-01 11:18 
*************************************************************************/</span> 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 64位寄存器，只能使用64位的变量存储，如果使用size为unsigned，那么
</span>    <span class="c1">// mov到寄存器之后，查看的寄存器状态值不是size的大小
</span>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">asm</span><span class="p">(</span>
            <span class="s">"mov $1, %%rax </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %1, %%rdi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %2, %%rsi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %3, %%rdx </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"syscall      </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="o">:</span><span class="s">"m"</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span> <span class="s">"m"</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">"m"</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
       <span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************************************************************* 
 * * FUNCTION NAME: close
 * * DESCRIPTION: implement with system call sys_close
 * * ARGS: 
 * rax = 0x3
 * rdi = fd
 * * RETURN VALUE: 
 * * AUTHOR: Jona
 * * CREATE TIME: 2019-02-01 11:22 
*************************************************************************/</span> 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">asm</span><span class="p">(</span>
            <span class="s">"mov $3, %%rax </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %1, %%rdi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"syscall      </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="o">:</span><span class="s">"m"</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
       <span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************************************************************* 
 * * FUNCTION NAME: seek
 * * DESCRIPTION: implement with system call sys_lseek
 * * ARGS: 
 * rax = 0x8
 * rdi = fd
 * rsi = offset
 * rdx = mode
 * * RETURN VALUE: 
 * * AUTHOR: Jona
 * * CREATE TIME: 2019-02-01 11:24 
*************************************************************************/</span> 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">seek</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">asm</span><span class="p">(</span>
            <span class="s">"mov $8, %%rax </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %1, %%rdi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %2, %%rsi </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"mov %3, %%rdx </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="s">"syscall      </span><span class="se">\n\t</span><span class="s">"</span>
            <span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="o">:</span><span class="s">"m"</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span> <span class="s">"m"</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="s">"m"</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
       <span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">access</span> <span class="o">=</span> <span class="mo">00700</span><span class="p">;</span>     <span class="c1">// file permissions
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">"w+"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_RDONLY</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">"a+"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_APPEND</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="p">)</span><span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">read</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">stream</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fwrite</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">write</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">stream</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">close</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fseek</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">seek</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">fp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>64位寄存器，就一定使用8字节的类型变量进行存储，不然会出现一些预想不到的结果。</p>

<h2 id="字符串操作">字符串操作</h2>

<p>字符串操作也是 minicrt 的一部分，实现字符串拷贝、计算字符串长度、比较两个字符串和整数与字符串之间的转换操作。这部分比较简单。在此不做说明，代码直接去文章开头给出的地址github上面看。</p>

<h2 id="字符串格式化">字符串格式化</h2>

<p>字符串格式化输出，就是我们经常使用的 printf 函数了，我们仅支持对整数和字符串的支持。fputc 和 fputs 函数的实现比较简单，使用我们之前实现的IO 文件操作 fwrite 接口来实现</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fputs</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fwrite</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于 printf，fprintf，vfprintf 这些具有可变参数的函数实现，就会复杂一点。我们仿照 <code class="highlighter-rouge">stdarg.h</code>中的宏定义来实现</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*********** printf OPERATIONS ***********/</span>
<span class="cm">/* _cdecl is default, and os push function args into stack from right to left.
 * the growth of stack is from high to low, so from left to right in function
 * args, address is from low to high. in va_arg, t is the last fixed argument,
 * plus offset to get all the unfixed arguments.
 * */</span>

<span class="cp">#ifdef ENVIRONMENT32
</span><span class="cm">/* alignment property */</span>
<span class="cp">#define _AUPBND                 (sizeof(long) - 1)
#define _ADNBND                 (sizeof(long) - 1)
</span>
<span class="cp">#define _bnd(X, bnd)            ((sizeof(X) + (bnd)) &amp; (~(bnd)))
</span>
<span class="cp">#define va_list char*
#define va_start(ap, arg)       ((ap) = (((char*)&amp;(arg)) + (_bnd(arg, _AUPBND))))
</span><span class="cm">/* offset of fixed argument is 32bytes, I don't know why */</span>
<span class="cp">#define va_arg(ap, t)           (*(t*)(((ap) += (_bnd(t, _AUPBND))) - (_bnd(t, _ADNBND))))
#define va_end(ap) ((va_list)0)
#else
#include &lt;stdarg.h&gt;
#endif
</span></code></pre></div></div>

<p><strong>这里有一个很恶心的地方，就是32位和64位不兼容的问题。</strong>32位系统中，函数参数传递使用的是栈，所以可以直接使用上面的宏来实现就可以，但是64位系统使用寄存器来传递参数，va_start 是一个结构体，不是一个简单的宏，具体实现不清楚，所以直接使用 <code class="highlighter-rouge">stdarg.h</code> <捂脸></捂脸></p>

<p>感兴趣可以查看 <a href="https://software.intel.com/pt-br/articles/linux-abi/">linux ABI</a></p>

<p>顺便解释一下上面 32 va 相关的宏的实现。在linux 中，gcc 默认的调用方式一般是 <code class="highlighter-rouge">__cdel</code>，函数参数入栈的原则是从右往左的，栈的增长方向是从大到小，也就是说，在可变参数的函数参数中，最右边的参数最先入栈，最左边的参数最后入栈，最先入栈的参数，地址是最大的，而最后入栈的参数，地址反而是最小的。所以，<code class="highlighter-rouge">va_start(ap, arg)</code>中，arg 为参数中最后一个固定参数，这个参数后面就是可变参数的地址，这个参数加上一个偏移就是可变参数的地址了。然后根据可变地址的类型，使用<code class="highlighter-rouge">va_arg</code>获取可变参数的值。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>           <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="p">)(((</span><span class="n">ap</span><span class="p">)</span> <span class="o">+=</span> <span class="p">(</span><span class="n">_bnd</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_AUPBND</span><span class="p">)))</span> <span class="o">-</span> <span class="p">(</span><span class="n">_bnd</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_ADNBND</span><span class="p">))))</span>
</code></pre></div></div>

<p>这个宏的实现中，ap的值+=之后就指向了下一个可变参数，但是可变参数的地址并没有变，所以后面再减去偏移获取前一个可变参数，这个宏计算之后，ap就已经指向了下一个可变参数了。</p>

<p>下面给出代码实现</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">vfprintf</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arglist</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">translating</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">format</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'%'</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">translating</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">translating</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>    <span class="c1">// %%
</span>                <span class="k">if</span> <span class="p">(</span><span class="n">fputc</span><span class="p">(</span><span class="sc">'%'</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">translating</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ret</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'d'</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">translating</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
                <span class="n">translating</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">itoa</span><span class="p">(</span><span class="n">va_arg</span><span class="p">(</span><span class="n">arglist</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="n">buf</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fputs</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fputc</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>    <span class="c1">// fputc&gt;0
</span>                    <span class="n">ret</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'s'</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">translating</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// %s
</span>                <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">arglist</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
                <span class="n">translating</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fputs</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fputc</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">ret</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">translating</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">translating</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fputc</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">ret</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fprintf</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">vfprintf</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">vfprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fnprintf</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">vfprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="minicrt-的使用">minicrt 的使用</h2>

<p>至此，minicrt的基本实现已经完成，那么如何编译和使用呢。我的makefile文件如下</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CC</span><span class="o">=</span>gcc
<span class="nv">CFLAGS</span><span class="o">=</span><span class="nt">-g</span> <span class="nt">-c</span> <span class="nt">-fno-builtin</span> <span class="nt">-nostdlib</span> <span class="nt">-fno-stack-protector</span>
<span class="nv">SOURCES</span><span class="o">=</span><span class="nf">$(</span><span class="nb">shell</span> <span class="nb">ls</span> <span class="k">*</span>.c<span class="nv">)</span>

<span class="nv">STATIC_LIB</span><span class="o">=</span>minicrt.a

<span class="nv">OBJECTS</span><span class="o">=</span><span class="err">$</span><span class="o">(</span>patsubst %.c, %.o, <span class="nv">$(SOURCES)</span><span class="o">)</span>

<span class="nl">.PHONY</span><span class="o">:</span><span class="nf">all</span>
<span class="nl">all</span><span class="o">:</span><span class="nf">$(OBJECTS)</span>

<span class="nl">.PHONY</span><span class="o">:</span><span class="nf">clean</span>
<span class="nl">clean</span><span class="o">:</span>
	<span class="nv">$(RM)</span> <span class="nv">$(OBJECTS)</span> <span class="nv">$(STATIC_LIB)</span>

<span class="nl">%.o</span><span class="o">:</span><span class="nf">%.c</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nv">$&lt;</span>

<span class="nl">.PHONY</span><span class="o">:</span><span class="nf">minicrt</span>
<span class="nl">minicrt</span><span class="o">:</span>
	ar <span class="nt">-rs</span> <span class="nv">$(STATIC_LIB)</span> malloc.o printf.o stdio.o string.o
</code></pre></div></div>

<p>将目标文件打包成静态库的形式。<code class="highlighter-rouge">-fno-builtin</code>不让gcc在默认情况使用内部的字符串操作函数，<code class="highlighter-rouge">-nostdlib</code>表示不使用任何来自 Glibc、Gcc的库文件和启动文件，它包含了<code class="highlighter-rouge">-nostartfiles</code>这个选项。<code class="highlighter-rouge">-fno-stack-protector</code>指关闭堆栈保护功能。</p>

<h2 id="测试">测试</h2>

<p>在当前目录下，创建一个 test 文件夹，然后编写一个简单的测试代码</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "../minicrt.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">**</span> <span class="n">v</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">argc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"a+"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">fp</span><span class="p">);</span>
        <span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

        <span class="n">free</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"number:%d string:%s"</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="s">"thanks"</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"use fprintf"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译程序</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">TARGET</span><span class="o">=</span>mini_test
<span class="nv">SOURCES</span><span class="o">=</span><span class="nf">$(</span><span class="nb">shell</span> <span class="nb">ls</span> <span class="k">*</span>.c<span class="nv">)</span>
<span class="nv">OBJECTS</span><span class="o">=</span><span class="err">$</span><span class="o">(</span>patsubst %.c, %.o, <span class="nv">$(SOURCES)</span><span class="o">)</span>

<span class="nv">CFLAGS</span><span class="o">=</span> <span class="nt">-fno-builtin</span> <span class="nt">-nostdlib</span> <span class="nt">-fno-stack-protector</span>

<span class="nl">$(TARGET)</span><span class="o">:</span><span class="nf">$(OBJECTS)</span>
	ld <span class="nt">-static</span> <span class="nt">-e</span> mini_crt_entry <span class="nt">-o</span> <span class="nv">$@</span> ../entry.o <span class="nv">$^</span> ../minicrt.a

<span class="nl">%.o</span><span class="o">:</span><span class="nf">%.c</span>
	gcc <span class="nt">-g</span> <span class="nt">-c</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nv">$^</span>

<span class="nl">.PHOMY</span><span class="o">:</span><span class="nf">clean</span>
<span class="nl">clean</span><span class="o">:</span>
	<span class="nv">$(RM)</span> <span class="nv">$(OBJECTS)</span> <span class="nv">$(TARGET)</span> core
</code></pre></div></div>

<p>程序运行结果如下</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./mini_test 1 2 3 4 5
./mini_test
1
2
3
4
5
use fprintf
use fnprintf
<span class="nv">$ </span><span class="nb">cat </span>test.txt
./mini_test
1
2
3
4
5
</code></pre></div></div>

<p>我们再来看下程序的入口函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	...
	20: 0000000000400cfa    51 FUNC    LOCAL  DEFAULT    1 read
    21: 0000000000400d2d    51 FUNC    LOCAL  DEFAULT    1 write
    22: 0000000000400d60    35 FUNC    LOCAL  DEFAULT    1 close
    23: 0000000000400d83    49 FUNC    LOCAL  DEFAULT    1 seek
    24: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS string.c
    25: 00000000004010cb    68 FUNC    GLOBAL DEFAULT    1 strcpy
    26: 0000000000400b4c   185 FUNC    GLOBAL DEFAULT    1 printf
    27: 00000000004006e6   163 FUNC    GLOBAL DEFAULT    1 mini_crt_heap_init
    28: 0000000000400567   339 FUNC    GLOBAL DEFAULT    1 malloc
    29: 0000000000400f25   260 FUNC    GLOBAL DEFAULT    1 itoa
    30: 0000000000400117   122 FUNC    GLOBAL DEFAULT    1 mini_crt_entry
    31: 0000000000400a8e   190 FUNC    GLOBAL DEFAULT    1 fprintf
    32: 0000000000400efc    41 FUNC    GLOBAL DEFAULT    1 fseek
    33: 0000000000400e77    54 FUNC    GLOBAL DEFAULT    1 fread
    34: 0000000000400cbd    11 FUNC    GLOBAL DEFAULT    1 mini_crt_io_init
    ...
</code></pre></div></div>

<p><code class="highlighter-rouge">mini_crt_entry</code> 的地址为 0000000000400117，使用 <code class="highlighter-rouge">readelf -h mini_test</code> 看下入口地址</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400117
  Start of program headers:          64 (bytes into file)
  Start of section headers:          13976 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         3
  Size of section headers:           64 (bytes)
  Number of section headers:         14
  Section header string table index: 11
</code></pre></div></div>

<p>说明<code class="highlighter-rouge">mini_crt_entry</code> 就是程序的入口函数。这个例子很简单，还可以继续补充。</p>

<p><strong>参考：</strong></p>

<ol>
  <li>程序员的自我修养-链接、装载与库</li>
  <li><a href="blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux System Call for X86 64</a></li>
</ol>
